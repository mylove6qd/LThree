<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>three-text</title>
</head>
<style>
    body {
        margin: 0;
        overflow: hidden;
        padding: 0;
    }

    canvas {
        outline: 0;
    }
</style>

<body>

    <div id="webgl">

    </div>

</body>
<script src="./LThree.js"></script>
<script src="./data/data.js"></script>
<script src="./plus/LineMaterial.js"></script>
<script src="./plus/LineSegmentsGeometry.js"></script>
<script src="./plus/LineSegments2.js"></script>
<script src="./plus/LineGeometry.js"></script>
<script src="./plus/Line2.js"></script>
<script src="./plus/CSS2DRenderer.js"></script>
<script src="./plus/OrbitControls.js"></script>
<script>
    var three = new LThree({ id: 'webgl' });

    //css2 渲染器
    let labelRenderer = new THREE.CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    document.body.appendChild(labelRenderer.domElement);

    //改变控制器 渲染
    three.controls = new THREE.OrbitControls(three.camera, labelRenderer.domElement);
    three.addRenderEvent('css2render', () => {
        labelRenderer.render(three.scene, three.camera);
    }, true);

    //相机位置
    three.camera.position.set(120.87436306922761, 97.08646666545671, -36.33511252219169);
    three.lookAt(new THREE.Vector3(120.87436306922761, 0, -36.33511252219169));

    //背景颜色
    three.renderer.setClearColor(new THREE.Color(0x000), 1.0);

    //加载数据
    loadGeoJson(chinaAll);

    three.update();

    function loadGeoJson(data) {

        let polygonBorderMaterial = new THREE.LineMaterial({
            color: 0x00FFFF,
            linewidth: 3,
            dashed: false
        })
        polygonBorderMaterial.resolution.set(window.innerWidth, window.innerHeight)

        let polygonContextMaterial = new THREE.MeshBasicMaterial({
            color: 0x2F4F4F,
            side: THREE.BackSide
        })

        //GeoJson 对象材质定义   
        let GeoJsonObj = {
            Point: null,
            MultiPoint: null,
            LineString: null,
            MultiLineString: null,
            Polygon: {
                border: polygonBorderMaterial,
                context: polygonContextMaterial
            },
            MultiPolygon: {
                border: polygonBorderMaterial,
                context: polygonContextMaterial
            },
        };

        if (data.constructor != Object) {
            console.error('GeoJson not object');
            return;
        }
        if (!data.hasOwnProperty('type') || !data.hasOwnProperty('features') || data.type != 'FeatureCollection') {
            console.error('GeoJson data error');
            return;
        }

        let features = data.features;

        let lineGroup = new THREE.Group();lineGroup.name = 'chinaLine';
        let contextGroup = new THREE.Group();contextGroup.name = 'chinaCentext';
        let lableGroup = new THREE.Group();lableGroup.name = 'provinceName';
        for (let i = 0; i < features.length; i++) {
            //添加标题
            let properties = features[i].properties;
            const div = document.createElement('div');
            div.textContent = properties.name;
            div.style.color = '#ffffff';
            let labelObj = new THREE.CSS2DObject(div);
            if (properties.hasOwnProperty('center') && (properties.name != '香港特别行政区') && (properties.name != '澳门特别行政区')) {
                let center = properties.centroid || properties.center;
                let lablePosition = lonlatToMercator(center[0], center[1]);
                labelObj.position.set(lablePosition.x, lablePosition.y + 0.02, lablePosition.z);
                lableGroup.add(labelObj);
            }

            let geometry = features[i].geometry;
            if (geometry.type == 'MultiPolygon') {
                let coordinates = geometry.coordinates;
                for (let k = 0; k < coordinates.length; k++) {
                    //经纬度数据
                    let vertices = [];
                    //样条曲线对象
                    let shape = new THREE.Shape();
                    //阿里的数据都是单层的 所以直接拿第一个数组
                    let Polygon = coordinates[k][0];
                    for (let m = 0; m < Polygon.length; m++) {
                        let lon = Polygon[m][0];
                        let lat = Polygon[m][1];
                        let Mercator = lonlatToMercator(lon, lat);
                        vertices.push(Mercator.x, Mercator.y + 0.01, Mercator.z);
                        //样条曲线
                        if (m == 0) {
                            shape.moveTo(Mercator.x, Mercator.z)
                        } else {
                            shape.lineTo(Mercator.x, Mercator.z)
                        }
                    }
                    //添加boder
                    let polygonBorderMaterial = GeoJsonObj[geometry.type].border;
                    if (polygonBorderMaterial != null) {
                        let lineGeometry = new THREE.LineGeometry();
                        lineGeometry.setPositions(vertices);
                        let line = new THREE.Line2(lineGeometry, polygonBorderMaterial);
                        line.computeLineDistances();
                        lineGroup.add(line);
                    }

                    //添加context
                    let polygonContextMaterial = GeoJsonObj[geometry.type].context;
                    if (polygonContextMaterial != null) {
                        let shapeGeometry = new THREE.ShapeGeometry(shape);
                        let context = new THREE.Mesh(shapeGeometry, polygonContextMaterial);
                        context.rotation.x = Math.PI / 2
                        contextGroup.add(context);
                    }
                }

            }
            if (geometry.type == 'Polygon') {
                let coordinates = geometry.coordinates;
                for (let k = 0; k < coordinates.length; k++) {
                    //经纬度数据
                    let vertices = [];
                    //样条曲线对象
                    let shape = new THREE.Shape();
                    //阿里的数据都是单层的 所以直接拿第一个数组
                    let Polygon = coordinates[k];
                    for (let m = 0; m < Polygon.length; m++) {
                        let lon = Polygon[m][0];
                        let lat = Polygon[m][1];
                        let Mercator = lonlatToMercator(lon, lat);
                        vertices.push(Mercator.x, Mercator.y + 0.01, Mercator.z);
                        //样条曲线
                        if (m == 0) {
                            shape.moveTo(Mercator.x, Mercator.z)
                        } else {
                            shape.lineTo(Mercator.x, Mercator.z)
                        }
                    }
                    //添加boder
                    let polygonBorderMaterial = GeoJsonObj[geometry.type].border;
                    if (polygonBorderMaterial != null) {
                        let lineGeometry = new THREE.LineGeometry();
                        lineGeometry.setPositions(vertices);
                        let line = new THREE.Line2(lineGeometry, polygonBorderMaterial);
                        line.computeLineDistances();
                        lineGroup.add(line);
                    }

                    //添加context
                    let polygonContextMaterial = GeoJsonObj[geometry.type].context;
                    if (polygonContextMaterial != null) {
                        let shapeGeometry = new THREE.ShapeGeometry(shape);
                        let context = new THREE.Mesh(shapeGeometry, polygonContextMaterial);
                        context.rotation.x = Math.PI / 2
                        contextGroup.add(context);
                    }
                }
            }
            three.scene.add(lineGroup)
            three.scene.add(contextGroup);
            three.scene.add(lableGroup);

        }

    }


    //经纬度转墨卡托
    function lonlatToMercator(lon, lat, height) {
        var z = height ? height : 0;
        var x = (lon / 180.0) * 20037508.3427892;
        var y = (Math.PI / 180.0) * lat;
        var tmp = Math.PI / 4.0 + y / 2.0;
        y = 20037508.3427892 * Math.log(Math.tan(tmp)) / Math.PI;
        return { x: x / 100000, y: z, z: -y / 100000 };
    }


</script>

</html>