<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>three-text</title>
</head>
<style>
    body {
        margin: 0;
        overflow: hidden;
        padding: 0;
    }

    canvas {
        outline: 0;
    }
</style>

<body>

    <div id="webgl">

    </div>

</body>
<script src="./LThree.js"></script>
<script src="./data/data.js"></script>
<script>
    var three = new LThree({ id: 'webgl' });

    three.initStats();

    //css2 渲染器
    let labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0px';
    labelRenderer.domElement.style.pointerEvents = 'none';
    document.body.appendChild(labelRenderer.domElement);
    //添加window 的resize事件监听 (浏览器窗口变动触发的方法)
    window.addEventListener('resize', (event) => {
        // 重新设置渲染器渲染范围
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
    });

    //改变控制器 渲染
    three.addRenderEvent('css2render', () => {
        labelRenderer.render(three.scene, three.camera);
    }, true);

    three.renderer.setClearColor(new THREE.Color(0xDCDCDC), 1.0);
    var helper = new THREE.GridHelper(40000, 100, 0xffffff, 0xffffff);
    three.scene.add(helper);

    // //相机位置
    three.animateCamera({
        points: new THREE.Vector3(114.79974123921474, 112.0542854496318, -40.52250750970406),
        target: new THREE.Vector3(114.79973993537538, 0, -40.52261956138473),
        time: 1000
    })
    //    three.camera.position.set(120.87436306922761, 97.08646666545671, -36.33511252219169);
    //    three.lookAt(new THREE.Vector3(120.87436306922761, 0, -20.33511252219169));

    //背景颜色
    three.renderer.setClearColor(new THREE.Color(0x000), 1.0);

    //加载数据
    loadGeoJson(chinaAll);

    three.update();

    initGui();

    //----------------------------------------------------------------------------------------------------------------------

    function initGui() {
        let param = {
            animateCamera: function () {
                var curve = [

                    new THREE.Vector3(117.33330323176656, 26.475280037984987, 68.32958984004887),
                    new THREE.Vector3(172.9087154806982, 16.011341134597163, -34.75671398243446),
                    new THREE.Vector3(113.45105820859051, 44.494803211092496, -156.42804491614794),
                    new THREE.Vector3(68.5883689527759, 16.86773022641919, -44.02430786630384),
                    new THREE.Vector3(117.33330323176656, 26.475280037984987, 68.32958984004887),
                    new THREE.Vector3(114.79974123921474, 112.0542854496318, -40.52250750970406),
                ];

                // var points = curve.getPoints( 50 );
                three.animateCamera({
                    points: curve,
                    time: 10000,
                })
            }
        }
        let gui = new GUI();
        gui.add(param, 'animateCamera')
    }

    function loadGeoJson(data) {

        let polygonBorderMaterial = new LineMaterial({
            color: 0x00FFFF,
            linewidth: 3,
            dashed: false
        })
        polygonBorderMaterial.resolution.set(window.innerWidth, window.innerHeight)

        //选中颜色
        let isChooecolor = new THREE.Color(0x1E90FF);
        let polygonContextMaterial = new THREE.MeshBasicMaterial({
            color: 0x2F4F4F,
            side: THREE.BackSide
        })

        //GeoJson 对象材质定义   
        let GeoJsonObj = {
            Point: null,
            MultiPoint: null,
            LineString: null,
            MultiLineString: null,
            Polygon: {
                border: polygonBorderMaterial,
                context: polygonContextMaterial
            },
            MultiPolygon: {
                border: polygonBorderMaterial,
                context: polygonContextMaterial
            },
        };

        if (data.constructor != Object) {
            console.error('GeoJson not object');
            return;
        }
        if (!data.hasOwnProperty('type') || !data.hasOwnProperty('features') || data.type != 'FeatureCollection') {
            console.error('GeoJson data error');
            return;
        }

        let features = data.features;

        let chinaGroup = new THREE.Group(); chinaGroup.name = 'chinaGroup';
        for (let i = 0; i < features.length; i++) {


            let properties = features[i].properties;
            let provinceGroup = new THREE.Group(); provinceGroup.name = properties.name;

            //添加标题
            const div = document.createElement('div');
            div.textContent = properties.name;
            div.style.color = '#ffffff';
            let labelObj = new CSS2DObject(div);
            if (properties.hasOwnProperty('center') && (properties.name != '香港特别行政区') && (properties.name != '澳门特别行政区')) {
                let center = properties.centroid || properties.center;
                let lablePosition = lonlatToMercator(center[0], center[1]);
                labelObj.position.set(lablePosition.x, lablePosition.y + 0.02, lablePosition.z);
                provinceGroup.add(labelObj);
            }

            let geometry = features[i].geometry;
            if (geometry.type == 'MultiPolygon') {
                let coordinates = geometry.coordinates;
                for (let k = 0; k < coordinates.length; k++) {
                    //经纬度数据
                    let vertices = [];
                    //样条曲线对象
                    let shape = new THREE.Shape();
                    //阿里的数据都是单层的 所以直接拿第一个数组
                    let Polygon = coordinates[k][0];
                    for (let m = 0; m < Polygon.length; m++) {
                        let lon = Polygon[m][0];
                        let lat = Polygon[m][1];
                        let Mercator = lonlatToMercator(lon, lat);
                        vertices.push(Mercator.x, Mercator.y + 0.01, Mercator.z);
                        //样条曲线
                        if (m == 0) {
                            shape.moveTo(Mercator.x, Mercator.z)
                        } else {
                            shape.lineTo(Mercator.x, Mercator.z)
                        }
                    }
                    //添加boder
                    let polygonBorderMaterial = GeoJsonObj[geometry.type].border;
                    if (polygonBorderMaterial != null) {
                        let lineGeometry = new LineGeometry();
                        lineGeometry.setPositions(vertices);
                        let line = new Line2(lineGeometry, polygonBorderMaterial);
                        line.computeLineDistances();
                        provinceGroup.add(line);
                    }

                    //添加context
                    let polygonContextMaterial = GeoJsonObj[geometry.type].context;
                    if (polygonContextMaterial != null) {
                        let shapeGeometry = new THREE.ShapeGeometry(shape);
                        let context = new THREE.Mesh(shapeGeometry, polygonContextMaterial.clone());
                        context.rotation.x = Math.PI / 2
                        context.on('mouseenter', function (obj) {
                            obj.material.color = isChooecolor.clone();
                        })
                        context.on('mouseleave', function (obj) {
                            obj.material.color = polygonContextMaterial.color.clone();
                        })
                        provinceGroup.add(context);
                    }
                }

            }
            if (geometry.type == 'Polygon') {
                let coordinates = geometry.coordinates;
                for (let k = 0; k < coordinates.length; k++) {
                    //经纬度数据
                    let vertices = [];
                    //样条曲线对象
                    let shape = new THREE.Shape();
                    //阿里的数据都是单层的 所以直接拿第一个数组
                    let Polygon = coordinates[k];
                    for (let m = 0; m < Polygon.length; m++) {
                        let lon = Polygon[m][0];
                        let lat = Polygon[m][1];
                        let Mercator = lonlatToMercator(lon, lat);
                        vertices.push(Mercator.x, Mercator.y + 0.01, Mercator.z);
                        //样条曲线
                        if (m == 0) {
                            shape.moveTo(Mercator.x, Mercator.z)
                        } else {
                            shape.lineTo(Mercator.x, Mercator.z)
                        }
                    }
                    //添加boder
                    let polygonBorderMaterial = GeoJsonObj[geometry.type].border;
                    if (polygonBorderMaterial != null) {
                        let lineGeometry = new LineGeometry();
                        lineGeometry.setPositions(vertices);
                        let line = new Line2(lineGeometry, polygonBorderMaterial);
                        line.computeLineDistances();
                        provinceGroup.add(line);
                    }

                    //添加context
                    let polygonContextMaterial = GeoJsonObj[geometry.type].context;
                    if (polygonContextMaterial != null) {
                        let shapeGeometry = new THREE.ShapeGeometry(shape);
                        let context = new THREE.Mesh(shapeGeometry, polygonContextMaterial.clone());
                        context.rotation.x = Math.PI / 2
                        context.on('mouseenter', function (obj) {
                            obj.material.color = isChooecolor.clone();
                        })
                        context.on('mouseleave', function (obj) {
                            obj.material.color = polygonContextMaterial.color.clone()
                        })
                        provinceGroup.add(context);
                    }
                }
            }
            three.scene.add(provinceGroup)

        }

    }


    //经纬度转墨卡托
    function lonlatToMercator(lon, lat, height) {
        var z = height ? height : 0;
        var x = (lon / 180.0) * 20037508.3427892;
        var y = (Math.PI / 180.0) * lat;
        var tmp = Math.PI / 4.0 + y / 2.0;
        y = 20037508.3427892 * Math.log(Math.tan(tmp)) / Math.PI;
        return { x: x / 100000, y: z, z: -y / 100000 };
    }


</script>

</html>